# üê≥ Docker-compose ‚Äì Introduction - Partie 3

<p align="center">
    <img src="../images/docker-compose-transparent.png" alt="YAML" width="350" />
</p>

---

## üëâ Voici quelques exemples de `docker-compose.yml` avec des services d'initialisation, du plus simple au plus √©labor√©.


## 1. Init container basique avec `depends_on`

```yaml
services:
  init:
    image: busybox
    command: sh -c "echo 'Initialisation termin√©e' && touch /data/ready"

    # Partage du volume pour que le service "app" puisse acc√©der au fichier cr√©√© par "init"
    # Ceci est un volume docker, pas un volume de type "bind" qui serait li√© √† un r√©pertoire de la station host.
    volumes:
      - shared-data:/data 
  
  app:
    image: nginx
    ports:
      - "80:80"
    depends_on:
      init:
        condition: service_completed_successfully
    volumes:
      - shared-data:/data
        name: un-volume

# Ceci est un volume interne √† Docker
volumes:
  shared-data:
```

Le service `app` ne d√©marre qu'une fois `init` termin√© avec succ√®s.

---

## 2. Plusieurs services d'init en parall√®le

```yaml
services:
  init-db:
    image: postgres:16
    entrypoint: ["sh", "-c", "until pg_isready -h db; do sleep 1; done"]
    depends_on:
      - db

  init-cache:
    image: redis:7
    entrypoint: ["sh", "-c", "until redis-cli -h cache ping; do sleep 1; done"]
    depends_on:
      - cache

  db:
    image: postgres:16
    environment:
      POSTGRES_PASSWORD: secret

  cache:
    image: redis:7

  app:
    image: nginx
    ports:
      - "80:80"    
    depends_on:
      init-db:
        condition: service_completed_successfully
      init-cache:
        condition: service_completed_successfully
```

Les deux inits s'ex√©cutent en parall√®le, et `app` attend qu'ils soient **tous les deux** termin√©s.

---

## R√©sum√© des conditions `depends_on`

| Condition | Signification |
|---|---|
| `service_started` | Le conteneur a d√©marr√© (d√©faut) |
| `service_healthy` | Le healthcheck passe |
| `service_completed_successfully` | Le conteneur s'est termin√© avec exit code 0 |

L'approche la plus robuste est en g√©n√©ral de combiner un **healthcheck** sur les d√©pendances et un **service de migration** d√©di√©.

---

## 3. Init qui g√©n√®re du contenu HTML avant le d√©marrage d'HTTPD

```yaml
services:
  init-content:
    image: busybox
    command:  |  # Utilisation de "| = \n" ou ">- = ram√®ne le tout sur une seule ligne" pour √©crire une commande multi-ligne plus lisible
      sh -c "
      echo '<h1>Hello depuis Docker 420!</h1>' > /var/www/html/index.html &&
      echo 'Build: '$(date) >> /var/www/html/index.html
      "
    volumes:
      - web-content:/var/www/html

  httpd:
    image: httpd:2.4
    ports:
      - "8080:80"
    volumes:
      - web-content:/usr/local/apache2/htdocs
    depends_on:
      init-content:
        condition: service_completed_successfully

volumes:
  web-content:
```

---

## 4. Init qui copie et personnalise la config Apache

```yaml
services:
  init-config:
    image: busybox
    environment:
      SERVER_NAME: monsite.local
      MAX_CLIENTS: 150
    command:
      - sh
      - -c
      - |
        cat > /config/httpd.conf << 'EOF'
        ServerName {{SERVER_NAME}}
        MaxRequestWorkers {{MAX_CLIENTS}}
        Listen 80

        DocumentRoot "/usr/local/apache2/htdocs"
        <Directory "/usr/local/apache2/htdocs">
            Options Indexes FollowSymLinks
            AllowOverride None
            Require all granted
        </Directory>
        EOF
        sed -i "s/{{SERVER_NAME}}/$SERVER_NAME/g" /config/httpd.conf &&
        sed -i "s/{{MAX_CLIENTS}}/$MAX_CLIENTS/g" /config/httpd.conf
    volumes:
      - apache-config:/config

  httpd:
    image: httpd:2.4
    ports:
      - "8080:80"
    volumes:
      - apache-config:/usr/local/apache2/conf
    depends_on:
      init-config:
        condition: service_completed_successfully

volumes:
  apache-config:
```

---

## 5. Stack compl√®te : Init + HTTPD + PHP-FPM + MySQL

```yaml
services:
  db:
    image: mysql:8
    environment:
      MYSQL_ROOT_PASSWORD: root
      MYSQL_DATABASE: myapp
      MYSQL_USER: user
      MYSQL_PASSWORD: secret
    volumes:
      - db-data:/var/lib/mysql
    healthcheck:
      test: ["CMD", "mysqladmin", "ping", "-h", "localhost"]
      interval: 5s
      retries: 10

  init-db:
    image: mysql:8
    command: sh -c "mysql -h db -u user -psecret myapp < /docker-entrypoint-initdb.d/seed.sql"
    volumes:
      - ./seed.sql:/docker-entrypoint-initdb.d/seed.sql
    depends_on:
      db:
        condition: service_healthy

  php:
    image: php:8.2-fpm
    volumes:
      - web-content:/var/www/html
    depends_on:
      init-db:
        condition: service_completed_successfully

  httpd:
    image: httpd:2.4
    ports:
      - "8080:80"
    volumes:
      - web-content:/var/www/html
      - ./httpd.conf:/usr/local/apache2/conf/httpd.conf
    depends_on:
      php:
        condition: service_started

volumes:
  db-data:
  web-content:
```

La cha√Æne est : `db` ‚Üí `init-db` ‚Üí `php` ‚Üí `httpd`.

---

## 4. Init qui t√©l√©charge un site statique (ex: documentation)

```yaml
services:
  init-site:
    image: alpine/curl
    command: sh -c "
      curl -L https://example.com/site.tar.gz -o /tmp/site.tar.gz &&
      tar -xzf /tmp/site.tar.gz -C /var/www/html --strip-components=1"
    volumes:
      - web-content:/var/www/html

  httpd:
    image: httpd:2.4
    ports:
      - "8080:80"
    volumes:
      - web-content:/usr/local/apache2/htdocs
    depends_on:
      init-site:
        condition: service_completed_successfully

volumes:
  web-content:
```

---

## 5. Init avec certificats SSL auto-sign√©s pour HTTPS

```yaml
services:
  init-ssl:
    image: alpine
    command:
      - sh
      - -c
      - |
        apk add --no-cache openssl &&
        openssl req -x509 -nodes -days 365 -newkey rsa:2048 \
          -keyout /certs/server.key \
          -out /certs/server.crt \
          -subj '/CN=localhost/O=Dev/C=FR'
    volumes:
      - ssl-certs:/certs

  init-config:
    image: httpd:2.4
    command:
      - sh
      - -c
      - |
        cp /usr/local/apache2/conf/httpd.conf /config/httpd.conf &&
        sed -i 's/#LoadModule ssl_module/LoadModule ssl_module/' /config/httpd.conf &&
        sed -i 's/#LoadModule socache_shmcb_module/LoadModule socache_shmcb_module/' /config/httpd.conf &&
        sed -i 's/#Include conf\/extra\/httpd-ssl.conf/Include conf\/extra\/httpd-ssl.conf/' /config/httpd.conf &&
        echo 'ServerName localhost' >> /config/httpd.conf
    volumes:
      - httpd-config:/config

  httpd:
    image: httpd:2.4
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ssl-certs:/usr/local/apache2/conf/ssl
      - httpd-config:/usr/local/apache2/conf
      - ./httpd-ssl.conf:/usr/local/apache2/conf/extra/httpd-ssl.conf
    depends_on:
      init-ssl:
        condition: service_completed_successfully
      init-config:
        condition: service_completed_successfully

volumes:
  ssl-certs:
  httpd-config:
```

Avec le fichier `httpd-ssl.conf` minimal :

```apache
Listen 443
SSLEngine on
SSLCertificateFile /usr/local/apache2/conf/ssl/server.crt
SSLCertificateKeyFile /usr/local/apache2/conf/ssl/server.key
```



---

## Exemple Postgres avec healthcheck

```yaml
# Note: db-1 -  FATAL:  role "postgres" does not exist
# Solution, effacer le volume pr√©c√©dent et recr√©er le conteneur
# docker-compose down -v

services:
  db:
    image: postgres:16
    environment:
      POSTGRES_USER: ${POSTGRES_USER}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
      POSTGRES_DB: ${POSTGRES_DB}
    volumes:
      - db-data:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER}"]
      interval: 5s
      timeout: 5s
      retries: 5

  pgadmin:
    image: dpage/pgadmin4
    environment:
      PGADMIN_DEFAULT_EMAIL: ${PGADMIN_EMAIL}       # admin@admin.com
      PGADMIN_DEFAULT_PASSWORD: ${PGADMIN_PASSWORD} # password
    ports:
      - "8080:80"
    depends_on:
      db:
        condition: service_healthy

#  adminer:
#    image: adminer
#    restart: always
#    ports:
#      - 88:8080
#    depends_on:
#      db:
#        condition: service_healthy


# Cr√©ation d'un volume interne √† Docker pour stocker les donn√©es de la base de donn√©es
volumes:
  db-data:
```

```
# Fichier .env
POSTGRES_USER=bob
POSTGRES_PASSWORD=binette
POSTGRES_DB=bob

PGADMIN_EMAIL=admin@admin.com
PGADMIN_PASSWORD=password
```

* Login et ajout (register) de la bd sous pgadmin:

<img src="../images/pgadmin.png" alt="YAML" width="500" />


## `healthcheck` ‚Äî Explication d√©taill√©e

Le healthcheck permet √† Docker de **surveiller l'√©tat de sant√©** d'un conteneur, au-del√† du simple fait qu'il tourne. Un conteneur peut √™tre d√©marr√© mais pas encore pr√™t √† accepter des connexions.

---

### `test`

```yaml
test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER}"]
```

D√©finit la commande √† ex√©cuter pour tester la sant√© du conteneur. Il existe deux formes :

| Forme | Description |
|---|---|
| `CMD` | Ex√©cute la commande directement, sans shell |
| `CMD-SHELL` | Ex√©cute la commande via `/bin/sh -c`, permet les variables et op√©rateurs shell |

`pg_isready` est un utilitaire fourni avec PostgreSQL qui v√©rifie si le serveur accepte des connexions. Il retourne :
- **exit code 0** ‚Üí le serveur est pr√™t ‚úÖ
- **exit code 1** ‚Üí le serveur refuse les connexions ‚ùå
- **exit code 2** ‚Üí aucune r√©ponse ‚ùå

Docker consid√®re le conteneur **healthy** uniquement si le code de retour est `0`.

---

### `interval`

```yaml
interval: 5s
```

Fr√©quence √† laquelle Docker ex√©cute le test. Ici toutes les **5 secondes**.

---

### `timeout`

```yaml
timeout: 5s
```

Dur√©e maximale accord√©e √† la commande de test pour s'ex√©cuter. Si elle d√©passe **5 secondes**, Docker consid√®re le test comme √©chou√©.

---

### `retries`

```yaml
retries: 5
```

Nombre d'√©checs cons√©cutifs avant de marquer le conteneur comme **unhealthy**. Ici Docker tol√®re **5 √©checs** avant de d√©clarer le conteneur d√©faillant.

---

### Cycle de vie d'un conteneur avec healthcheck

```
d√©marrage ‚Üí starting
              ‚Üì
         test √©choue (jusqu'√† 5 fois)
              ‚Üì
         test r√©ussit ‚Üí healthy   ‚Üê depends_on condition: service_healthy attend cet √©tat
              ‚Üì
         test √©choue 5 fois de suite ‚Üí unhealthy
```

---

### Param√®tre optionnel : `start_period`

```yaml
healthcheck:
  test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER}"]
  interval: 5s
  timeout: 5s
  retries: 5
  start_period: 10s   # ‚Üê d√©lai de gr√¢ce au d√©marrage
```

Pendant le `start_period`, les √©checs ne sont pas comptabilis√©s dans les `retries`. Utile pour les services qui mettent du temps √† initialiser (ex: PostgreSQL qui restaure une grosse base).

---

## R√©capitulatif des patterns utilis√©s

| Pattern | Cas d'usage |
|---|---|
| `busybox` + volume partag√© | G√©n√©rer du contenu statique |
| `sed` sur un template de config | Personnaliser `httpd.conf` dynamiquement |
| `alpine/curl` | T√©l√©charger des assets au d√©marrage |
| `alpine/openssl` | G√©n√©rer des certificats SSL |
| `mysql` init + healthcheck | Seeder une BDD avant de lancer l'app |